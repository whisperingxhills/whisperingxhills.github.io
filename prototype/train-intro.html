<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Whispering Hills</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a0908}

/* Three.js canvas */
#tunnel-canvas{position:fixed;top:0;left:0;width:100%;height:100%;z-index:3}

/* POV vignette — train window effect */
#vignette{
  position:fixed;top:0;left:0;width:100%;height:100%;z-index:4;
  pointer-events:none;
  background:radial-gradient(ellipse at center, transparent 15%, rgba(10,9,8,0.3) 25%, rgba(10,9,8,0.7) 35%, rgba(10,9,8,0.95) 45%, rgba(10,9,8,1) 55%);
}

/* CSS Door overlay — hidden until crossfade */
#door-overlay{position:fixed;top:0;left:0;width:100%;height:100%;z-index:2;opacity:0;pointer-events:none;display:flex}
.door-panel{
  width:50%;height:100%;position:relative;
  background:linear-gradient(180deg,#4a4540 0%,#3e3a35 30%,#35312d 70%,#2a2724 100%);
}
.door-panel::before{
  content:'';position:absolute;top:0;bottom:0;width:100%;
  background:repeating-linear-gradient(90deg,transparent,transparent 3px,rgba(255,255,255,0.015) 3px,rgba(255,255,255,0.015) 4px);
  pointer-events:none;
}
/* Rubber edge strips */
.door-panel.left::after{
  content:'';position:absolute;top:0;right:0;width:6px;height:100%;
  background:linear-gradient(180deg,#1a1816,#222019,#1a1816);
  box-shadow:inset 1px 0 0 rgba(255,255,255,0.05);
}
.door-panel.right::after{
  content:'';position:absolute;top:0;left:0;width:6px;height:100%;
  background:linear-gradient(180deg,#1a1816,#222019,#1a1816);
  box-shadow:inset -1px 0 0 rgba(255,255,255,0.05);
}
/* Door seam */
#door-seam{
  position:absolute;top:0;left:50%;width:2px;height:100%;
  background:#111;z-index:4;transform:translateX(-50%);
  box-shadow:0 0 4px rgba(0,0,0,0.8);
}

/* Site content */
#site-content{
  position:fixed;top:0;left:0;width:100%;height:100%;z-index:0;
  background:#F5F0E8;display:flex;align-items:center;justify-content:center;
  font-family:'Georgia',serif;
}
#site-inner{
  text-align:center;padding:3rem;
  border:1px solid #d4cfc6;
  box-shadow:inset 0 0 0 4px #F5F0E8,inset 0 0 0 5px #d4cfc6;
  position:relative;
}
#site-inner::before{
  content:'';position:absolute;top:8px;left:8px;right:8px;bottom:8px;
  border:1px solid rgba(180,170,155,0.3);pointer-events:none;
}
#site-inner h1{
  font-size:clamp(1.8rem,5vw,3.5rem);font-weight:400;letter-spacing:0.3em;
  color:#2a2520;text-transform:uppercase;
}
#site-inner .sub{
  font-size:clamp(0.7rem,1.5vw,0.9rem);letter-spacing:0.5em;
  color:#8a7f70;margin-top:0.8rem;text-transform:uppercase;
}
</style>
</head>
<body>

<canvas id="tunnel-canvas"></canvas>
<div id="vignette"></div>

<div id="door-overlay">
  <div class="door-panel left"></div>
  <div class="door-panel right"></div>
  <div id="door-seam"></div>
</div>

<div id="site-content">
  <div id="site-inner">
    <h1>Whispering Hills</h1>
    <div class="sub">Est. 2024</div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gsap@3/dist/gsap.min.js"></script>
<script>
(function(){
  const canvas = document.getElementById('tunnel-canvas');
  const doorOverlay = document.getElementById('door-overlay');
  const doorSeam = document.getElementById('door-seam');
  const leftPanel = doorOverlay.querySelector('.left');
  const rightPanel = doorOverlay.querySelector('.right');

  // --- Three.js Setup ---
  const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:false});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 0.9;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0a0908);
  scene.fog = new THREE.FogExp2(0x0a0908, 0.065);

  const camera = new THREE.PerspectiveCamera(72, window.innerWidth/window.innerHeight, 0.1, 120);
  camera.position.set(0, 0.3, 0);
  camera.lookAt(0, 0.3, -1);

  // Ambient
  scene.add(new THREE.AmbientLight(0x1a1510, 0.3));

  // --- Smoke Textures ---
  function makeSmokeTex(color, alpha){
    const c = document.createElement('canvas');
    c.width = 64; c.height = 64;
    const ctx = c.getContext('2d');
    const g = ctx.createRadialGradient(32,32,0,32,32,32);
    g.addColorStop(0, `rgba(${color},${alpha})`);
    g.addColorStop(0.4, `rgba(${color},${alpha*0.5})`);
    g.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,64,64);
    return new THREE.CanvasTexture(c);
  }
  const smokeTex1 = makeSmokeTex('180,170,155', 0.25);
  const smokeTex2 = makeSmokeTex('200,160,100', 0.18);

  // --- Smoke Sprites ---
  const smokes = [];
  const SMOKE_COUNT = 200;
  const SMOKE_DEPTH = 70;
  for(let i=0;i<SMOKE_COUNT;i++){
    const tex = Math.random()>0.35 ? smokeTex1 : smokeTex2;
    const mat = new THREE.SpriteMaterial({map:tex, transparent:true, opacity:0.6+Math.random()*0.4, depthWrite:false, blending:THREE.AdditiveBlending});
    const s = new THREE.Sprite(mat);
    const scale = 1.5 + Math.random()*4;
    s.scale.set(scale, scale, 1);
    s.position.set((Math.random()-0.5)*6, (Math.random()-0.5)*4, -Math.random()*SMOKE_DEPTH);
    scene.add(s);
    smokes.push({sprite:s, baseZ:s.position.z, speed:0.8+Math.random()*0.4, baseScale:scale});
  }

  // --- Tunnel Lights ---
  const lights = [];
  const LIGHT_COUNT = 12;
  const LIGHT_SPACING = 5.5;
  for(let i=0;i<LIGHT_COUNT;i++){
    const g = new THREE.Group();
    const z = -i * LIGHT_SPACING;

    // Light bar
    const barGeo = new THREE.BoxGeometry(1.8, 0.06, 0.15);
    const barMat = new THREE.MeshStandardMaterial({color:0xfff5e0, emissive:0xffe8b0, emissiveIntensity:2.5});
    const bar = new THREE.Mesh(barGeo, barMat);
    bar.position.set(0, 2.8, 0);
    g.add(bar);

    // Glow sprite
    const glowC = document.createElement('canvas');
    glowC.width=64;glowC.height=64;
    const gctx=glowC.getContext('2d');
    const gg=gctx.createRadialGradient(32,32,0,32,32,32);
    gg.addColorStop(0,'rgba(255,240,200,0.7)');
    gg.addColorStop(0.3,'rgba(255,220,160,0.3)');
    gg.addColorStop(1,'rgba(0,0,0,0)');
    gctx.fillStyle=gg;gctx.fillRect(0,0,64,64);
    const glowTex=new THREE.CanvasTexture(glowC);
    const glowMat=new THREE.SpriteMaterial({map:glowTex,transparent:true,opacity:0.9,blending:THREE.AdditiveBlending,depthWrite:false});
    const glow=new THREE.Sprite(glowMat);
    glow.scale.set(3,1.5,1);
    glow.position.set(0,2.8,0);
    g.add(glow);

    // Spill light
    const pl = new THREE.PointLight(0xffe0a0, 0.6, 8, 2);
    pl.position.set(0, 2.6, 0);
    g.add(pl);

    g.position.z = z;
    scene.add(g);
    lights.push({group:g, baseZ:z});
  }

  // --- 3D Door Wall ---
  const DOOR_START_Z = -50;
  const DOOR_STOP_Z = 0.3;
  const doorColor = 0x1a1816;

  // Left door plane
  const doorGeo = new THREE.PlaneGeometry(5, 7);
  const doorMat = new THREE.MeshStandardMaterial({color:doorColor, roughness:0.7, metalness:0.3});
  const doorLeft3D = new THREE.Mesh(doorGeo, doorMat);
  doorLeft3D.position.set(-2.5, 0.3, DOOR_START_Z);
  scene.add(doorLeft3D);

  // Right door plane
  const doorRight3D = new THREE.Mesh(doorGeo, doorMat.clone());
  doorRight3D.position.set(2.5, 0.3, DOOR_START_Z);
  scene.add(doorRight3D);

  // Surrounding wall (fills edges)
  const wallGeo = new THREE.PlaneGeometry(20, 14);
  const wallMat = new THREE.MeshStandardMaterial({color:0x1a1816, roughness:0.9, metalness:0.1});
  const wall = new THREE.Mesh(wallGeo, wallMat);
  wall.position.set(0, 0.3, DOOR_START_Z - 0.01);
  scene.add(wall);

  // Seam line between doors
  const seamGeo = new THREE.PlaneGeometry(0.03, 7);
  const seamMat = new THREE.MeshBasicMaterial({color:0x111111});
  const seam3D = new THREE.Mesh(seamGeo, seamMat);
  seam3D.position.set(0, 0.3, DOOR_START_Z + 0.02);
  scene.add(seam3D);

  // Warm light on door surface
  const doorLight = new THREE.PointLight(0xffe0a0, 0.3, 8, 2);
  doorLight.position.set(0, 2.5, DOOR_START_Z + 4);
  scene.add(doorLight);

  // Group all door-related for easy z movement
  const doorGroup = new THREE.Group();
  // Remove from scene, add to group
  scene.remove(doorLeft3D, doorRight3D, wall, seam3D, doorLight);
  doorLeft3D.position.z = 0;
  doorRight3D.position.z = 0;
  wall.position.z = -0.01;
  seam3D.position.z = 0.02;
  doorLight.position.z = 6;
  doorGroup.add(doorLeft3D, doorRight3D, wall, seam3D, doorLight);
  doorGroup.position.z = DOOR_START_Z;
  doorGroup.position.y = 0.3;
  scene.add(doorGroup);

  // --- Animation State ---
  const state = {speed: 1.0, lightOpacity: 1.0}; // 1 = full speed, 0 = stopped
  let totalDistance = 0;
  const FULL_SPEED = 18; // units/sec at speed=1

  // --- Audio ---
  const ambientAudio = new Audio('tunnel-ambient.mp3');
  ambientAudio.loop = true;
  ambientAudio.volume = 0.7;
  const brakeAudio = new Audio('brake.mp3');
  brakeAudio.volume = 0.8;
  const doorHissAudio = new Audio('door-hiss.mp3');
  doorHissAudio.volume = 0.9;
  const chimeAudio = new Audio('station-chime.mp3');
  chimeAudio.volume = 0.85;

  // --- GSAP Timeline ---
  const tl = gsap.timeline({paused:true});

  // Phase 1: Full speed (0-2s)
  tl.to(state, {duration:2, speed:1, ease:'none'}, 0);

  // Phase 2: Deceleration (2-5.5s) — smoke/lights slow to stop
  tl.call(()=>{ brakeAudio.play(); }, [], 2);
  tl.to(state, {duration:3.5, speed:0, ease:'power2.out'}, 2);

  // Black wall behind doors — massive so edges are never visible
  const blackoutGeo = new THREE.PlaneGeometry(100, 80);
  const blackoutMat = new THREE.MeshBasicMaterial({color:0x0a0908, side:THREE.DoubleSide});
  const blackout = new THREE.Mesh(blackoutGeo, blackoutMat);
  blackout.position.z = -0.5;
  doorGroup.add(blackout);

  // Vignette overlay handles edge fading now

  // Door approaches in sync with decel — arrives when smoke stops
  tl.to(doorGroup.position, {duration:3.2, z:DOOR_STOP_Z, ease:'power2.out'}, 2.3);

  // Fade ambient audio during decel
  tl.to(ambientAudio, {duration:3.5, volume:0.1, ease:'power2.out'}, 2);

  // Lights vanish 0.5s before everything stops
  tl.to(state, {duration:1, lightOpacity:0, ease:'power1.out'}, 4);

  // Phase 3: Stillness (5.5-6s)
  // Phase 4: Crossfade to CSS doors
  tl.to(doorOverlay, {duration:0.01, opacity:1, ease:'none'}, 6);
  tl.to(canvas, {duration:0.25, opacity:0, ease:'none'}, 6);
  tl.to('#vignette', {duration:0.5, opacity:0, ease:'power1.out'}, 6);

  // Door hiss
  tl.call(()=>{ doorHissAudio.play(); }, [], 6.2);

  // Phase 5: Doors open
  tl.to(leftPanel, {duration:1.4, x:'-100%', ease:'power2.inOut'}, 6.3);
  tl.to(rightPanel, {duration:1.4, x:'100%', ease:'power2.inOut'}, 6.3);
  tl.to(doorSeam, {duration:0.3, opacity:0, ease:'none'}, 6.3);

  // Station chime + HX-808 welcome
  tl.call(()=>{ chimeAudio.play(); }, [], 6.9);

  // Phase 6: Cleanup
  tl.call(()=>{
    ambientAudio.pause();
    canvas.remove();
    renderer.dispose();
    setTimeout(()=>{
      doorOverlay.remove();
    }, 300);
  }, [], 7.8);

  // --- Render Loop ---
  let lastTime = 0;
  let running = true;

  // Pre-calculate total distance the door needs to travel
  // Door goes from DOOR_START_Z to DOOR_STOP_Z = 55.3 units
  // We need speed profile integral to equal this distance
  // Full speed phase: 2s * 18 = 36 units
  // Decel phase: integral of power2.out over 3.5s * 18
  // power2.out: progress = 1-(1-t)^2, so speed = d/dt[progress] mapped... 
  // Actually let's just track it in real-time and scale

  // Better approach: move door toward camera each frame based on state.speed
  // The door needs to travel 55.3 units total
  // At full speed (18u/s) for 2s = 36 units
  // Remaining 19.3 units during decel (3.5s)
  // Average speed during power2.out decel ≈ 18 * 1/3 = 6 u/s → 6*3.5=21 ≈ close enough
  // This should work naturally

  function animate(time){
    if(!running) return;
    requestAnimationFrame(animate);

    const dt = lastTime ? Math.min((time-lastTime)/1000, 0.05) : 0.016;
    lastTime = time;

    const currentSpeed = state.speed * FULL_SPEED;
    const dz = currentSpeed * dt;
    totalDistance += dz;

    // Move smoke
    for(const s of smokes){
      s.sprite.position.z += dz;
      if(s.sprite.position.z > 3){
        s.sprite.position.z = -SMOKE_DEPTH + Math.random()*5;
        s.sprite.position.x = (Math.random()-0.5)*6;
        s.sprite.position.y = (Math.random()-0.5)*4;
      }
      // Subtle rotation
      s.sprite.material.rotation += dt * 0.3 * s.speed;
    }

    // Move lights + fade
    for(const l of lights){
      l.group.position.z += dz;
      if(l.group.position.z > 5){
        l.group.position.z -= LIGHT_COUNT * LIGHT_SPACING;
      }
      l.group.visible = state.lightOpacity > 0.01;
      l.group.children.forEach(c => {
        if(c.material) c.material.opacity = state.lightOpacity;
      });
    }

    // Door position is GSAP-driven, not physics
    // Thin fog as doors approach
    const doorProgress = (doorGroup.position.z - DOOR_START_Z) / (DOOR_STOP_Z - DOOR_START_Z);
    scene.fog.density = 0.035 * (1 - Math.max(0, doorProgress) * 0.6);

    renderer.render(scene, camera);
  }

  requestAnimationFrame(animate);

  // Start on click/tap (browsers require user interaction for audio)
  function startExperience() {
    ambientAudio.play();
    tl.play();
    document.removeEventListener('click', startExperience);
    document.removeEventListener('touchstart', startExperience);
  }

  // Auto-play if possible, fall back to click
  ambientAudio.play().then(() => {
    tl.play();
  }).catch(() => {
    // Browser blocked autoplay — wait for click
    document.addEventListener('click', startExperience);
    document.addEventListener('touchstart', startExperience);
  });

  // --- Resize ---
  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  /* audio initialized above */
})();
</script>
</body>
</html>
